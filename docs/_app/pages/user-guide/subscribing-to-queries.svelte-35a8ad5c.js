import{S as e,i as t,s as a,a0 as n,a1 as s,a2 as r,l as i,k as o,e as u,t as c,j as h,L as l,a3 as b,d as m,n as d,c as y,a as f,g as p,m as g,X as v,b as E,a4 as w,F as S,f as $,o as P,G as T,x as q,u as k,v as D}from"../../chunks/vendor-836b274b.js";import{b as j}from"../../chunks/paths-6758d194.js";function x(e){let t,a,x,A,C,U,I,O,N,W,Y,Q,M,V,B,G,H,z,F,L,R,X,J,K,Z,_,ee,te,ae,ne,se,re,ie,oe,ue,ce,he,le,be,me,de,ye,fe,pe,ge,ve,Ee,we,Se,$e,Pe,Te,qe,ke,De,je,xe,Ae,Ce,Ue,Ie,Oe,Ne,We,Ye,Qe,Me,Ve,Be,Ge,He;return ee=new n({props:{language:s,code:"let smiths: (User & UserData)[] = [];\npubsub.subscribeEntities(\n  {\n    class: User\n  },\n  {\n    type: '&',\n    like: ['name', '% Smith']\n  }\n)(\n  (update) => {\n    // This function will be called once initially with an array of\n    // entities, then again every time there's a change with an\n    // update object.\n    // The updateArray function will add any newly matching entities,\n    // update any existing entities that have changed, and remove any\n    // entities that no longer match (including deleted entities).\n    pubsub.updateArray(smiths, update);\n  },\n  (e) => {\n    alert('Error: ' + e.textStatus);\n  }\n);"}}),re=new n({props:{language:s,code:"let smiths: (User & UserData)[] = [];\npubsub.subscribeEntities(\n  {\n    class: User\n  },\n  {\n    type: '&',\n    like: ['name', '% Smith']\n  }\n)(\n  (update) => {\n    pubsub.updateArray(smiths, update);\n  },\n  (e) => {\n    alert('Error: ' + e.textStatus);\n  },\n  (count) => {\n    // This function will be called each time the count of\n    // subscribers to this query changes.\n    console.log(`There are now ${count} users watching the Smiths.`);\n  }\n);"}}),fe=new n({props:{language:s,code:"let smiths: (User & UserData)[] = [];\nlet subscription = pubsub.subscribeEntities(\n  {\n    class: User\n  },\n  {\n    type: '&',\n    like: ['name', '% Smith']\n  }\n)((update) => {\n  pubsub.updateArray(smiths, update);\n});\n\nonDestroy(() => {\n  subscription.unsubscribe();\n});"}}),ke=new n({props:{language:s,code:"let subscription = pubsub.subscribeWith(\n  smithEntity,\n  () => {\n    if (smithEntity.guid == null) {\n      if (confirm('Someone deleted Mr. Smith! Do you want to restore him?')) {\n        smithEntity.$save();\n      }\n    } else {\n      alert(\"Mr. Smith's entity has changed!\");\n    }\n  },\n  (e) => {\n    alert('Error: ' + e.textStatus);\n  },\n  (count) => {\n    console.log(`There are now ${count} users watching Mr. Smith.`);\n  }\n);\n\nonDestroy(() => {\n  subscription.unsubscribe();\n});"}}),{c(){t=new r,a=i(),x=o(),A=u("section"),C=u("header"),U=u("h1"),I=c("Subscribing to Queries"),O=o(),N=u("p"),W=c("Subscribing to a query lets you receive updates to that query. This is a\n    powerful tool for collaborative apps. It's also just as easy as making a\n    regular entity query."),Y=o(),Q=u("p"),M=c("Before we get started, you can follow the "),V=u("a"),B=c("PubSub Server Package"),G=c(" page to set up a Nymph PubSub server."),H=o(),z=u("p"),F=c("You can use the "),L=u("code"),R=c("subscribeEntities"),X=c(" method on PubSub to subscribe\n    to a query. It will return a function you can call to subscribe to the\n    query. That function accepts a resolve and reject callback, similar to a\n    promise. The resolve function will receive an update, which will at first be\n    an array of entities, then will be an update object with instructions that\n    "),J=u("code"),K=c("updateArray"),Z=c(" uses to update the original array."),_=o(),h(ee.$$.fragment),te=o(),ae=u("p"),ne=c("You can also receive a count of how many subscribers there are to that\n    query. The count is given to a third callback."),se=o(),h(re.$$.fragment),ie=o(),oe=u("p"),ue=c("To unsubscribe from the query, use the "),ce=u("code"),he=c("unsubscribe"),le=c(" method on\n    the\n    "),be=u("code"),me=c("PubSubSubscription"),de=c(" object returned by the function."),ye=o(),h(fe.$$.fragment),pe=o(),ge=u("p"),ve=c("You can subscribe to changes to an entity with the "),Ee=u("code"),we=c("subscribeWith"),Se=c("\n    method. This method accepts the callbacks directly and returns a\n    "),$e=u("code"),Pe=c("PubSubSubscription"),Te=c("\n    object."),qe=o(),h(ke.$$.fragment),De=o(),je=u("p"),xe=c("Warning: Subscriptions can lead to resource leaks if left open. Take care to\n    unsubscribe to every query you are no longer watching."),Ae=o(),Ce=u("p"),Ue=c("Warning: The PubSub server is smart about removing entities that no longer\n    match when a new entity matches, but there are some queries that can have\n    changes in their matching entities without any change to the server (like\n    relative time queries). These queries won't necessarily be updated correctly\n    in due time by the PubSub server."),Ie=o(),Oe=u("section"),Ne=u("div"),We=u("div"),Ye=u("a"),Qe=c("Previous: Entity Querying"),Me=o(),Ve=u("div"),Be=u("a"),Ge=c("Next: Entity Class"),this.h()},l(e){const n=l('[data-svelte="svelte-tpafo0"]',document.head);t=b(n),a=i(),n.forEach(m),x=d(e),A=y(e,"SECTION",{});var s=f(A);C=y(s,"HEADER",{class:!0});var r=f(C);U=y(r,"H1",{style:!0});var o=f(U);I=p(o,"Subscribing to Queries"),o.forEach(m),r.forEach(m),O=d(s),N=y(s,"P",{});var u=f(N);W=p(u,"Subscribing to a query lets you receive updates to that query. This is a\n    powerful tool for collaborative apps. It's also just as easy as making a\n    regular entity query."),u.forEach(m),Y=d(s),Q=y(s,"P",{});var c=f(Q);M=p(c,"Before we get started, you can follow the "),V=y(c,"A",{href:!0});var h=f(V);B=p(h,"PubSub Server Package"),h.forEach(m),G=p(c," page to set up a Nymph PubSub server."),c.forEach(m),H=d(s),z=y(s,"P",{});var v=f(z);F=p(v,"You can use the "),L=y(v,"CODE",{});var E=f(L);R=p(E,"subscribeEntities"),E.forEach(m),X=p(v," method on PubSub to subscribe\n    to a query. It will return a function you can call to subscribe to the\n    query. That function accepts a resolve and reject callback, similar to a\n    promise. The resolve function will receive an update, which will at first be\n    an array of entities, then will be an update object with instructions that\n    "),J=y(v,"CODE",{});var w=f(J);K=p(w,"updateArray"),w.forEach(m),Z=p(v," uses to update the original array."),v.forEach(m),_=d(s),g(ee.$$.fragment,s),te=d(s),ae=y(s,"P",{});var S=f(ae);ne=p(S,"You can also receive a count of how many subscribers there are to that\n    query. The count is given to a third callback."),S.forEach(m),se=d(s),g(re.$$.fragment,s),ie=d(s),oe=y(s,"P",{});var $=f(oe);ue=p($,"To unsubscribe from the query, use the "),ce=y($,"CODE",{});var P=f(ce);he=p(P,"unsubscribe"),P.forEach(m),le=p($," method on\n    the\n    "),be=y($,"CODE",{});var T=f(be);me=p(T,"PubSubSubscription"),T.forEach(m),de=p($," object returned by the function."),$.forEach(m),ye=d(s),g(fe.$$.fragment,s),pe=d(s),ge=y(s,"P",{});var q=f(ge);ve=p(q,"You can subscribe to changes to an entity with the "),Ee=y(q,"CODE",{});var k=f(Ee);we=p(k,"subscribeWith"),k.forEach(m),Se=p(q,"\n    method. This method accepts the callbacks directly and returns a\n    "),$e=y(q,"CODE",{});var D=f($e);Pe=p(D,"PubSubSubscription"),D.forEach(m),Te=p(q,"\n    object."),q.forEach(m),qe=d(s),g(ke.$$.fragment,s),De=d(s),je=y(s,"P",{});var j=f(je);xe=p(j,"Warning: Subscriptions can lead to resource leaks if left open. Take care to\n    unsubscribe to every query you are no longer watching."),j.forEach(m),Ae=d(s),Ce=y(s,"P",{});var He=f(Ce);Ue=p(He,"Warning: The PubSub server is smart about removing entities that no longer\n    match when a new entity matches, but there are some queries that can have\n    changes in their matching entities without any change to the server (like\n    relative time queries). These queries won't necessarily be updated correctly\n    in due time by the PubSub server."),He.forEach(m),s.forEach(m),Ie=d(e),Oe=y(e,"SECTION",{});var ze=f(Oe);Ne=y(ze,"DIV",{class:!0});var Fe=f(Ne);We=y(Fe,"DIV",{class:!0});var Le=f(We);Ye=y(Le,"A",{href:!0,class:!0,style:!0});var Re=f(Ye);Qe=p(Re,"Previous: Entity Querying"),Re.forEach(m),Le.forEach(m),Me=d(Fe),Ve=y(Fe,"DIV",{class:!0,style:!0});var Xe=f(Ve);Be=y(Xe,"A",{href:!0,class:!0,style:!0});var Je=f(Be);Ge=p(Je,"Next: Entity Class"),Je.forEach(m),Xe.forEach(m),Fe.forEach(m),ze.forEach(m),this.h()},h(){document.title="Subscribing to Queries - User Guide - Nymph",t.a=a,v(U,"font-size","3em"),E(C,"class","major"),E(V,"href",j+"/packages/pubsub/"),E(Ye,"href",j+"/user-guide/entity-querying"),E(Ye,"class","button"),v(Ye,"margin",".5em"),E(We,"class","col-6 col-12-small"),E(Be,"href",j+"/user-guide/entity-class"),E(Be,"class","button"),v(Be,"margin",".5em"),E(Ve,"class","col-6 col-12-small"),v(Ve,"text-align","end"),E(Ne,"class","row")},m(e,n){t.m(w,document.head),S(document.head,a),$(e,x,n),$(e,A,n),S(A,C),S(C,U),S(U,I),S(A,O),S(A,N),S(N,W),S(A,Y),S(A,Q),S(Q,M),S(Q,V),S(V,B),S(Q,G),S(A,H),S(A,z),S(z,F),S(z,L),S(L,R),S(z,X),S(z,J),S(J,K),S(z,Z),S(A,_),P(ee,A,null),S(A,te),S(A,ae),S(ae,ne),S(A,se),P(re,A,null),S(A,ie),S(A,oe),S(oe,ue),S(oe,ce),S(ce,he),S(oe,le),S(oe,be),S(be,me),S(oe,de),S(A,ye),P(fe,A,null),S(A,pe),S(A,ge),S(ge,ve),S(ge,Ee),S(Ee,we),S(ge,Se),S(ge,$e),S($e,Pe),S(ge,Te),S(A,qe),P(ke,A,null),S(A,De),S(A,je),S(je,xe),S(A,Ae),S(A,Ce),S(Ce,Ue),$(e,Ie,n),$(e,Oe,n),S(Oe,Ne),S(Ne,We),S(We,Ye),S(Ye,Qe),S(Ne,Me),S(Ne,Ve),S(Ve,Be),S(Be,Ge),He=!0},p:T,i(e){He||(q(ee.$$.fragment,e),q(re.$$.fragment,e),q(fe.$$.fragment,e),q(ke.$$.fragment,e),He=!0)},o(e){k(ee.$$.fragment,e),k(re.$$.fragment,e),k(fe.$$.fragment,e),k(ke.$$.fragment,e),He=!1},d(e){m(a),e&&t.d(),e&&m(x),e&&m(A),D(ee),D(re),D(fe),D(ke),e&&m(Ie),e&&m(Oe)}}}class A extends e{constructor(e){super(),t(this,e,null,x,a,{})}}export{A as default};
