import{S as e,i as t,s as a,a0 as n,a1 as s,a2 as r,l as o,k as i,e as h,t as c,j as l,L as d,a3 as u,d as y,n as f,c as m,a as E,g as v,m as p,X as g,b as $,a4 as w,F as b,f as C,o as D,G as I,x as O,u as T,v as k}from"../../chunks/vendor-836b274b.js";import{b as j}from"../../chunks/paths-6758d194.js";function N(e){let t,a,N,U,q,P,G,L,A,S,M,x,F,Y,z,B,V,H,Q,R,X,J,K,W,Z,_,ee,te,ae,ne,se,re,oe,ie,he,ce,le,de,ue,ye,fe,me,Ee,ve,pe,ge,$e,we,be,Ce,De,Ie,Oe,Te,ke,je,Ne,Ue,qe,Pe,Ge,Le,Ae,Se,Me,xe,Fe,Ye,ze,Be,Ve,He,Qe,Re,Xe,Je,Ke,We,Ze,_e,et,tt,at,nt,st,rt,ot,it,ht,ct,lt,dt,ut,yt,ft,mt,Et,vt,pt,gt,$t,wt,bt,Ct,Dt,It,Ot,Tt,kt,jt,Nt,Ut,qt,Pt,Gt,Lt,At,St,Mt,xt,Ft,Yt,zt,Bt,Vt,Ht,Qt,Rt,Xt,Jt,Kt,Wt,Zt,_t,ea,ta,aa,na,sa,ra,oa,ia,ha,ca,la,da,ua,ya,fa,ma,Ea,va,pa,ga,$a,wa,ba,Ca,Da,Ia,Oa,Ta,ka,ja,Na,Ua,qa,Pa,Ga,La,Aa,Sa,Ma,xa,Fa,Ya,za,Ba,Va,Ha,Qa,Ra,Xa,Ja,Ka,Wa,Za,_a,en,tn,an,nn,sn,rn,on,hn,cn,ln,dn,un,yn,fn,mn,En,vn,pn,gn,$n,wn,bn,Cn,Dn,In,On,Tn,kn,jn,Nn,Un,qn,Pn,Gn,Ln,An,Sn,Mn,xn,Fn,Yn,zn,Bn,Vn;return oe=new n({props:{language:s,code:"const entity = await MyEntityClass.factory();\n\nentity.$addTag('foo', 'bar');\nentity.$hasTag('foo'); // True\n\nentity.$removeTag('foo', 'bar');\nentity.$hasTag('foo'); // False"}}),je=new n({props:{language:s,code:"// Create some entities.\nlet entity = await MyEntityClass.factory();\nentity.foo = await MyEntityClass.factory();\nentity.foo.bar = 'Old value.';\nawait entity.foo.$save();\nawait entity.$save();\n\n// Reset the entity to a copy just pulled from the DB.\nentity = await nymph.getEntity(\n  { class: MyEntityClass },\n  { type: '&', guid: entity.guid }\n);\n\n// Get a copy of the referenced entity.\nlet instOfFoo = await nymph.getEntity(\n  { class: MyEntityClass },\n  { type: '&', guid: entity.foo.guid }\n);\n// And change a value on it.\ninstOfFoo.bar = 'New value.';\nawait instOfFoo.$save();\n\nconsole.log(entity.foo.bar); // Outputs 'Old value.'\n// If on Node.js\nentity.$clearCache();\n// Else if on the client\nawait entity.$refresh();\nawait entity.foo.$ready();\n// End if\nconsole.log(entity.foo.bar); // Outputs 'New value.'"}}),Se=new n({props:{language:s,code:"// Create an entity.\nconst entity = await MyEntityClass.factory();\nentity.foo = 'Old value.';\nawait entity.$save();\n\n// Get a copy of the entity.\nconst instOfEnt = await nymph.getEntity(\n  { class: MyEntityClass },\n  { type: '&', guid: entity.guid }\n);\n// And change a value on it.\ninstOfEnt.foo = 'New value.';\nawait instOfEnt.$save();\n\nconsole.log(entity.foo); // Outputs 'Old value.'\nawait entity.$refresh();\nconsole.log(entity.foo); // Outputs 'New value.'"}}),ct=new n({props:{language:s,code:"const entity = await MyEntityClass.factory();\n\n// Save the entity.\nawait entity.$save();\n// or\nawait nymph.saveEntity(entity);\n// or\nawait nymph.saveEntities([entity]);\n\n// (Client only.) Save only the data that has changed.\nawait entity.$patch();\n// or\nawait nymph.patchEntity(entity);\n// or\nawait nymph.patchEntities([entity]);\n\n// Delete the entity.\nawait entity.$delete();\n// or\nawait nymph.deleteEntity(entity);\n// or\nawait nymph.deleteEntities([entity]);"}}),qa=new n({props:{language:s,code:"// Assuming the entity with GUID 'a4c1591d6ea91c8450d2d360' exists.\nlet entity = await MyEntityClass.factory('a4c1591d6ea91c8450d2d360');\nlet entity2 = await MyEntityClass.factory('a4c1591d6ea91c8450d2d360');\n\nentity2.someProp = 'some new value';\nentity.$is(entity2); // True\nentity.$equals(entity2); // False\n\nconst arr = [null, null, entity];\nentity.$arraySearch(arr); // 2\nentity.$inArray(arr); // True\nentity.$arraySearch(arr, true); // -1\nentity.$inArray(arr, true); // false"}}),Pn=new n({props:{language:s,code:"// You can use $serverCall and serverCallStatic directly.\ntry {\n  const success: boolean = await todo.$serverCall('$archive', []);\n  if (!success) {\n    alert(\"Couldn't archive \" + todo.name);\n  }\n} catch (e) {\n  alert('Error: ' + e.textStatus + \"\nCouldn't archive \" + todo.name);\n}\n\n// Or you can define methods like this in your client class.\nclass Todo extends Entity<TodoData> {\n  // ...\n\n  static async archiveAllDone(onlyOlderThanDay: boolean): Promise<boolean> {\n    return await this.serverCallStatic('archiveAllDone', [onlyOlderThanDay]);\n  }\n\n  async $archive(): Promise<boolean> {\n    return await this.$serverCall('archive', []);\n  }\n}\n\n// You'd use them like this.\nconst success = await Todo.archiveAllDone(true);\n\n// And\nconst todo = await Todo.factory();\nconst success = await todo.$archive();"}}),{c(){t=new r,a=o(),N=i(),U=h("section"),q=h("header"),P=h("h1"),G=c("Entity Class"),L=i(),A=h("p"),S=c('Entities in Nymph work pretty much like regular objects, and this is due to\n    the Entity class. The Entity class constructor returns a proxy to allow\n    accessing data on it just like a regular object while keeping track of\n    changes and only unserializing data from the DB when it\'s first accessed.\n    Instance methods and properties begin with "$" to differentiate them from\n    data.'),M=i(),x=h("p"),F=c('In the client, assigning a property internally marks that property as\n    "dirty", and calling '),Y=h("code"),z=c("$patch"),B=c(" will push just the changed\n    properties up to the server, whereas "),V=h("code"),H=c("$save"),Q=c(" would push all properties."),R=i(),X=h("p"),J=c("Entities can be organized using tags. To add, remove, and check tags, the\n    methods "),K=h("code"),W=c("$addTag"),Z=c(", "),_=h("code"),ee=c("$removeTag"),te=c(", and\n    "),ae=h("code"),ne=c("$hasTag"),se=c(" are used, respectively. Each takes any number of tags as\n    arguments."),re=i(),l(oe.$$.fragment),ie=i(),he=h("p"),ce=c('In Node.js, entities that have been saved inside another entity\'s property\n    are loaded as "sleeping references". This means their data is not actually\n    pulled from the database. It will "wake up" when you first try to access\n    something other than its GUID.'),le=i(),de=h("p"),ue=c("In the client, there are still sleeping references, but they can't be loaded\n    synchronously. Instead, they are loaded with the "),ye=h("code"),fe=c("$ready"),me=c(" method,\n    or by using the "),Ee=h("code"),ve=c("$readyAll"),pe=c(" method on the entity that contains them."),ge=i(),$e=h("p"),we=c("To clear the cache of referenced entities, so that the next time one is\n    accessed it will be pulled from the database, use the "),be=h("code"),Ce=c("$clearCache"),De=c("\n    method in Node.js and the "),Ie=h("code"),Oe=c("$refresh"),Te=c(" method in the client."),ke=i(),l(je.$$.fragment),Ne=i(),Ue=h("p"),qe=c("Much like clearing the entity cache, you may need to refresh the entity's\n    own data in Node.js. Use the "),Pe=h("code"),Ge=c("$refresh"),Le=c(" method, just like in the client,\n    for this."),Ae=i(),l(Se.$$.fragment),Me=i(),xe=h("p"),Fe=c("To save an entity, use the "),Ye=h("code"),ze=c("$save"),Be=c(" method. Likewise, to delete\n    the entity, use the "),Ve=h("code"),He=c("$delete"),Qe=c(" method. You can also call the\n    "),Re=h("code"),Xe=c("saveEntity"),Je=c(",\n    "),Ke=h("code"),We=c("deleteEntity"),Ze=c(", and "),_e=h("code"),et=c("deleteEntityByID"),tt=c(" methods of\n    "),at=h("code"),nt=c("Nymph"),st=c(". The "),rt=h("code"),ot=c("Entity"),it=c(" class uses these methods."),ht=i(),l(ct.$$.fragment),lt=i(),dt=h("p"),ut=c("Entities can't be checked using the "),yt=h("code"),ft=c("=="),mt=c(" operator. Instead, you can\n    use the following entity methods."),Et=i(),vt=h("ul"),pt=h("li"),gt=h("code"),$t=c("$is"),wt=c(" - Perform a less strict comparison of two entities\n      (basically a GUID check). To return true, the entities must meet the\n      following criteria.\n      "),bt=h("ul"),Ct=h("li"),Dt=c("They must be entities."),It=i(),Ot=h("li"),Tt=c("They must have equal GUIDs, or both can have no GUID."),kt=i(),jt=h("li"),Nt=c("If they have no GUIDs, their data must be equal."),Ut=i(),qt=h("li"),Pt=h("code"),Gt=c("$equals"),Lt=c(" - Perform a more strict comparison of two entities\n      (basically a GUID + class + data check). To return true, the entities must\n      meet the following criteria.\n      "),At=h("ul"),St=h("li"),Mt=c("They must be entities."),xt=i(),Ft=h("li"),Yt=c("They must have equal GUIDs, or both can have no GUID."),zt=i(),Bt=h("li"),Vt=c("They must be instances of the same class."),Ht=i(),Qt=h("li"),Rt=c("Their data must be equal."),Xt=i(),Jt=h("li"),Kt=h("code"),Wt=c("$inArray"),Zt=c(" - Check whether the entity is in an array. Takes two\n      arguments, the array and a boolean "),_t=h("code"),ea=c("strict"),ta=c(". If\n      "),aa=h("code"),na=c("strict"),sa=c("\n      is false, the function uses "),ra=h("code"),oa=c("$is"),ia=c(" to compare, and if it's true,\n      the function uses "),ha=h("code"),ca=c("$equals"),la=c("."),da=i(),ua=h("li"),ya=h("code"),fa=c("$arraySearch"),ma=c(" - Search an array for the entity and return the\n      corresponding key. Takes two arguments, the array and a boolean\n      "),Ea=h("code"),va=c("strict"),pa=c(". If "),ga=h("code"),$a=c("strict"),wa=c(" is false, the function uses\n      "),ba=h("code"),Ca=c("$is"),Da=c("\n      to compare, and if it's true, the function uses "),Ia=h("code"),Oa=c("$equals"),Ta=c(". This\n      method may return 0, which evaluates to false, so you should use\n      "),ka=h("code"),ja=c("$inArray"),Na=c(" if you are only checking whether the entity is in the\n      array."),Ua=i(),l(qa.$$.fragment),Pa=i(),Ga=h("p"),La=c("Client side Nymph entities can use the "),Aa=h("code"),Sa=c("$serverCall"),Ma=c(" method to\n    call methods on a server side instance of the entity.\n    "),xa=h("code"),Fa=c("$serverCall"),Ya=c(" expects three parameters."),za=i(),Ba=h("ul"),Va=h("li"),Ha=h("code"),Qa=c("method"),Ra=c(" - the name of the method to call on the server side object."),Xa=i(),Ja=h("li"),Ka=h("code"),Wa=c("params"),Za=c(" - an array of the parameters to pass to the method."),_a=i(),en=h("li"),tn=h("code"),an=c("stateless"),nn=c(" - if set to true, the method won't update the entity\n      with the returned server side representation."),sn=i(),rn=h("p"),on=c("Normally, when you use this method, just before the promise is fulfilled,\n    the entity's data will be replaced with that of the entity on the server\n    side after the method was run. This will cause any awoken entities in the\n    data of your entity to be replaced with sleeping entities, so you will have\n    to run "),hn=h("code"),cn=c("$readyAll"),ln=c(" again. If you know that the server side method\n    will not change any of the data on the entity, you can set\n    "),dn=h("code"),un=c("stateless"),yn=c(" to true."),fn=i(),mn=h("p"),En=c("You can also call static methods on the server with "),vn=h("code"),pn=c("serverCallStatic"),gn=c("."),$n=i(),wn=h("p"),bn=c("In order to be called from the client side, the method must be listed in the\n    "),Cn=h("code"),Dn=c("$clientEnabledMethods"),In=c(" or\n    "),On=h("code"),Tn=c("clientEnabledStaticMethods"),kn=c(" property in the Node.js class. This\n    guards against a user submitting tailored requests to perform potentially\n    dangerous tasks on the server side. If the method is not listed, the request\n    will fail with a "),jn=h("code"),Nn=c("403 Forbidden"),Un=c(" status."),qn=i(),l(Pn.$$.fragment),Gn=i(),Ln=h("section"),An=h("div"),Sn=h("div"),Mn=h("a"),xn=c("Previous: Subscribing to Queries"),Fn=i(),Yn=h("div"),zn=h("a"),Bn=c("Next: Defining Entities"),this.h()},l(e){const n=d('[data-svelte="svelte-24q1tq"]',document.head);t=u(n),a=o(),n.forEach(y),N=f(e),U=m(e,"SECTION",{});var s=E(U);q=m(s,"HEADER",{class:!0});var r=E(q);P=m(r,"H1",{style:!0});var i=E(P);G=v(i,"Entity Class"),i.forEach(y),r.forEach(y),L=f(s),A=m(s,"P",{});var h=E(A);S=v(h,'Entities in Nymph work pretty much like regular objects, and this is due to\n    the Entity class. The Entity class constructor returns a proxy to allow\n    accessing data on it just like a regular object while keeping track of\n    changes and only unserializing data from the DB when it\'s first accessed.\n    Instance methods and properties begin with "$" to differentiate them from\n    data.'),h.forEach(y),M=f(s),x=m(s,"P",{});var c=E(x);F=v(c,'In the client, assigning a property internally marks that property as\n    "dirty", and calling '),Y=m(c,"CODE",{});var l=E(Y);z=v(l,"$patch"),l.forEach(y),B=v(c," will push just the changed\n    properties up to the server, whereas "),V=m(c,"CODE",{});var g=E(V);H=v(g,"$save"),g.forEach(y),Q=v(c," would push all properties."),c.forEach(y),R=f(s),X=m(s,"P",{});var $=E(X);J=v($,"Entities can be organized using tags. To add, remove, and check tags, the\n    methods "),K=m($,"CODE",{});var w=E(K);W=v(w,"$addTag"),w.forEach(y),Z=v($,", "),_=m($,"CODE",{});var b=E(_);ee=v(b,"$removeTag"),b.forEach(y),te=v($,", and\n    "),ae=m($,"CODE",{});var C=E(ae);ne=v(C,"$hasTag"),C.forEach(y),se=v($," are used, respectively. Each takes any number of tags as\n    arguments."),$.forEach(y),re=f(s),p(oe.$$.fragment,s),ie=f(s),he=m(s,"P",{});var D=E(he);ce=v(D,'In Node.js, entities that have been saved inside another entity\'s property\n    are loaded as "sleeping references". This means their data is not actually\n    pulled from the database. It will "wake up" when you first try to access\n    something other than its GUID.'),D.forEach(y),le=f(s),de=m(s,"P",{});var I=E(de);ue=v(I,"In the client, there are still sleeping references, but they can't be loaded\n    synchronously. Instead, they are loaded with the "),ye=m(I,"CODE",{});var O=E(ye);fe=v(O,"$ready"),O.forEach(y),me=v(I," method,\n    or by using the "),Ee=m(I,"CODE",{});var T=E(Ee);ve=v(T,"$readyAll"),T.forEach(y),pe=v(I," method on the entity that contains them."),I.forEach(y),ge=f(s),$e=m(s,"P",{});var k=E($e);we=v(k,"To clear the cache of referenced entities, so that the next time one is\n    accessed it will be pulled from the database, use the "),be=m(k,"CODE",{});var j=E(be);Ce=v(j,"$clearCache"),j.forEach(y),De=v(k,"\n    method in Node.js and the "),Ie=m(k,"CODE",{});var Vn=E(Ie);Oe=v(Vn,"$refresh"),Vn.forEach(y),Te=v(k," method in the client."),k.forEach(y),ke=f(s),p(je.$$.fragment,s),Ne=f(s),Ue=m(s,"P",{});var Hn=E(Ue);qe=v(Hn,"Much like clearing the entity cache, you may need to refresh the entity's\n    own data in Node.js. Use the "),Pe=m(Hn,"CODE",{});var Qn=E(Pe);Ge=v(Qn,"$refresh"),Qn.forEach(y),Le=v(Hn," method, just like in the client,\n    for this."),Hn.forEach(y),Ae=f(s),p(Se.$$.fragment,s),Me=f(s),xe=m(s,"P",{});var Rn=E(xe);Fe=v(Rn,"To save an entity, use the "),Ye=m(Rn,"CODE",{});var Xn=E(Ye);ze=v(Xn,"$save"),Xn.forEach(y),Be=v(Rn," method. Likewise, to delete\n    the entity, use the "),Ve=m(Rn,"CODE",{});var Jn=E(Ve);He=v(Jn,"$delete"),Jn.forEach(y),Qe=v(Rn," method. You can also call the\n    "),Re=m(Rn,"CODE",{});var Kn=E(Re);Xe=v(Kn,"saveEntity"),Kn.forEach(y),Je=v(Rn,",\n    "),Ke=m(Rn,"CODE",{});var Wn=E(Ke);We=v(Wn,"deleteEntity"),Wn.forEach(y),Ze=v(Rn,", and "),_e=m(Rn,"CODE",{});var Zn=E(_e);et=v(Zn,"deleteEntityByID"),Zn.forEach(y),tt=v(Rn," methods of\n    "),at=m(Rn,"CODE",{});var _n=E(at);nt=v(_n,"Nymph"),_n.forEach(y),st=v(Rn,". The "),rt=m(Rn,"CODE",{});var es=E(rt);ot=v(es,"Entity"),es.forEach(y),it=v(Rn," class uses these methods."),Rn.forEach(y),ht=f(s),p(ct.$$.fragment,s),lt=f(s),dt=m(s,"P",{});var ts=E(dt);ut=v(ts,"Entities can't be checked using the "),yt=m(ts,"CODE",{});var as=E(yt);ft=v(as,"=="),as.forEach(y),mt=v(ts," operator. Instead, you can\n    use the following entity methods."),ts.forEach(y),Et=f(s),vt=m(s,"UL",{});var ns=E(vt);pt=m(ns,"LI",{});var ss=E(pt);gt=m(ss,"CODE",{});var rs=E(gt);$t=v(rs,"$is"),rs.forEach(y),wt=v(ss," - Perform a less strict comparison of two entities\n      (basically a GUID check). To return true, the entities must meet the\n      following criteria.\n      "),bt=m(ss,"UL",{});var os=E(bt);Ct=m(os,"LI",{});var is=E(Ct);Dt=v(is,"They must be entities."),is.forEach(y),It=f(os),Ot=m(os,"LI",{});var hs=E(Ot);Tt=v(hs,"They must have equal GUIDs, or both can have no GUID."),hs.forEach(y),kt=f(os),jt=m(os,"LI",{});var cs=E(jt);Nt=v(cs,"If they have no GUIDs, their data must be equal."),cs.forEach(y),os.forEach(y),ss.forEach(y),Ut=f(ns),qt=m(ns,"LI",{});var ls=E(qt);Pt=m(ls,"CODE",{});var ds=E(Pt);Gt=v(ds,"$equals"),ds.forEach(y),Lt=v(ls," - Perform a more strict comparison of two entities\n      (basically a GUID + class + data check). To return true, the entities must\n      meet the following criteria.\n      "),At=m(ls,"UL",{});var us=E(At);St=m(us,"LI",{});var ys=E(St);Mt=v(ys,"They must be entities."),ys.forEach(y),xt=f(us),Ft=m(us,"LI",{});var fs=E(Ft);Yt=v(fs,"They must have equal GUIDs, or both can have no GUID."),fs.forEach(y),zt=f(us),Bt=m(us,"LI",{});var ms=E(Bt);Vt=v(ms,"They must be instances of the same class."),ms.forEach(y),Ht=f(us),Qt=m(us,"LI",{});var Es=E(Qt);Rt=v(Es,"Their data must be equal."),Es.forEach(y),us.forEach(y),ls.forEach(y),Xt=f(ns),Jt=m(ns,"LI",{});var vs=E(Jt);Kt=m(vs,"CODE",{});var ps=E(Kt);Wt=v(ps,"$inArray"),ps.forEach(y),Zt=v(vs," - Check whether the entity is in an array. Takes two\n      arguments, the array and a boolean "),_t=m(vs,"CODE",{});var gs=E(_t);ea=v(gs,"strict"),gs.forEach(y),ta=v(vs,". If\n      "),aa=m(vs,"CODE",{});var $s=E(aa);na=v($s,"strict"),$s.forEach(y),sa=v(vs,"\n      is false, the function uses "),ra=m(vs,"CODE",{});var ws=E(ra);oa=v(ws,"$is"),ws.forEach(y),ia=v(vs," to compare, and if it's true,\n      the function uses "),ha=m(vs,"CODE",{});var bs=E(ha);ca=v(bs,"$equals"),bs.forEach(y),la=v(vs,"."),vs.forEach(y),da=f(ns),ua=m(ns,"LI",{});var Cs=E(ua);ya=m(Cs,"CODE",{});var Ds=E(ya);fa=v(Ds,"$arraySearch"),Ds.forEach(y),ma=v(Cs," - Search an array for the entity and return the\n      corresponding key. Takes two arguments, the array and a boolean\n      "),Ea=m(Cs,"CODE",{});var Is=E(Ea);va=v(Is,"strict"),Is.forEach(y),pa=v(Cs,". If "),ga=m(Cs,"CODE",{});var Os=E(ga);$a=v(Os,"strict"),Os.forEach(y),wa=v(Cs," is false, the function uses\n      "),ba=m(Cs,"CODE",{});var Ts=E(ba);Ca=v(Ts,"$is"),Ts.forEach(y),Da=v(Cs,"\n      to compare, and if it's true, the function uses "),Ia=m(Cs,"CODE",{});var ks=E(Ia);Oa=v(ks,"$equals"),ks.forEach(y),Ta=v(Cs,". This\n      method may return 0, which evaluates to false, so you should use\n      "),ka=m(Cs,"CODE",{});var js=E(ka);ja=v(js,"$inArray"),js.forEach(y),Na=v(Cs," if you are only checking whether the entity is in the\n      array."),Cs.forEach(y),ns.forEach(y),Ua=f(s),p(qa.$$.fragment,s),Pa=f(s),Ga=m(s,"P",{});var Ns=E(Ga);La=v(Ns,"Client side Nymph entities can use the "),Aa=m(Ns,"CODE",{});var Us=E(Aa);Sa=v(Us,"$serverCall"),Us.forEach(y),Ma=v(Ns," method to\n    call methods on a server side instance of the entity.\n    "),xa=m(Ns,"CODE",{});var qs=E(xa);Fa=v(qs,"$serverCall"),qs.forEach(y),Ya=v(Ns," expects three parameters."),Ns.forEach(y),za=f(s),Ba=m(s,"UL",{});var Ps=E(Ba);Va=m(Ps,"LI",{});var Gs=E(Va);Ha=m(Gs,"CODE",{});var Ls=E(Ha);Qa=v(Ls,"method"),Ls.forEach(y),Ra=v(Gs," - the name of the method to call on the server side object."),Gs.forEach(y),Xa=f(Ps),Ja=m(Ps,"LI",{});var As=E(Ja);Ka=m(As,"CODE",{});var Ss=E(Ka);Wa=v(Ss,"params"),Ss.forEach(y),Za=v(As," - an array of the parameters to pass to the method."),As.forEach(y),_a=f(Ps),en=m(Ps,"LI",{});var Ms=E(en);tn=m(Ms,"CODE",{});var xs=E(tn);an=v(xs,"stateless"),xs.forEach(y),nn=v(Ms," - if set to true, the method won't update the entity\n      with the returned server side representation."),Ms.forEach(y),Ps.forEach(y),sn=f(s),rn=m(s,"P",{});var Fs=E(rn);on=v(Fs,"Normally, when you use this method, just before the promise is fulfilled,\n    the entity's data will be replaced with that of the entity on the server\n    side after the method was run. This will cause any awoken entities in the\n    data of your entity to be replaced with sleeping entities, so you will have\n    to run "),hn=m(Fs,"CODE",{});var Ys=E(hn);cn=v(Ys,"$readyAll"),Ys.forEach(y),ln=v(Fs," again. If you know that the server side method\n    will not change any of the data on the entity, you can set\n    "),dn=m(Fs,"CODE",{});var zs=E(dn);un=v(zs,"stateless"),zs.forEach(y),yn=v(Fs," to true."),Fs.forEach(y),fn=f(s),mn=m(s,"P",{});var Bs=E(mn);En=v(Bs,"You can also call static methods on the server with "),vn=m(Bs,"CODE",{});var Vs=E(vn);pn=v(Vs,"serverCallStatic"),Vs.forEach(y),gn=v(Bs,"."),Bs.forEach(y),$n=f(s),wn=m(s,"P",{});var Hs=E(wn);bn=v(Hs,"In order to be called from the client side, the method must be listed in the\n    "),Cn=m(Hs,"CODE",{});var Qs=E(Cn);Dn=v(Qs,"$clientEnabledMethods"),Qs.forEach(y),In=v(Hs," or\n    "),On=m(Hs,"CODE",{});var Rs=E(On);Tn=v(Rs,"clientEnabledStaticMethods"),Rs.forEach(y),kn=v(Hs," property in the Node.js class. This\n    guards against a user submitting tailored requests to perform potentially\n    dangerous tasks on the server side. If the method is not listed, the request\n    will fail with a "),jn=m(Hs,"CODE",{});var Xs=E(jn);Nn=v(Xs,"403 Forbidden"),Xs.forEach(y),Un=v(Hs," status."),Hs.forEach(y),qn=f(s),p(Pn.$$.fragment,s),s.forEach(y),Gn=f(e),Ln=m(e,"SECTION",{});var Js=E(Ln);An=m(Js,"DIV",{class:!0});var Ks=E(An);Sn=m(Ks,"DIV",{class:!0});var Ws=E(Sn);Mn=m(Ws,"A",{href:!0,class:!0,style:!0});var Zs=E(Mn);xn=v(Zs,"Previous: Subscribing to Queries"),Zs.forEach(y),Ws.forEach(y),Fn=f(Ks),Yn=m(Ks,"DIV",{class:!0,style:!0});var _s=E(Yn);zn=m(_s,"A",{href:!0,class:!0,style:!0});var er=E(zn);Bn=v(er,"Next: Defining Entities"),er.forEach(y),_s.forEach(y),Ks.forEach(y),Js.forEach(y),this.h()},h(){document.title="Entity Class - User Guide - Nymph.js",t.a=a,g(P,"font-size","3em"),$(q,"class","major"),$(Mn,"href",j+"/user-guide/subscribing-to-queries"),$(Mn,"class","button"),g(Mn,"margin",".5em"),$(Sn,"class","col-6 col-12-small"),$(zn,"href",j+"/user-guide/defining-entities"),$(zn,"class","button"),g(zn,"margin",".5em"),$(Yn,"class","col-6 col-12-small"),g(Yn,"text-align","end"),$(An,"class","row")},m(e,n){t.m(w,document.head),b(document.head,a),C(e,N,n),C(e,U,n),b(U,q),b(q,P),b(P,G),b(U,L),b(U,A),b(A,S),b(U,M),b(U,x),b(x,F),b(x,Y),b(Y,z),b(x,B),b(x,V),b(V,H),b(x,Q),b(U,R),b(U,X),b(X,J),b(X,K),b(K,W),b(X,Z),b(X,_),b(_,ee),b(X,te),b(X,ae),b(ae,ne),b(X,se),b(U,re),D(oe,U,null),b(U,ie),b(U,he),b(he,ce),b(U,le),b(U,de),b(de,ue),b(de,ye),b(ye,fe),b(de,me),b(de,Ee),b(Ee,ve),b(de,pe),b(U,ge),b(U,$e),b($e,we),b($e,be),b(be,Ce),b($e,De),b($e,Ie),b(Ie,Oe),b($e,Te),b(U,ke),D(je,U,null),b(U,Ne),b(U,Ue),b(Ue,qe),b(Ue,Pe),b(Pe,Ge),b(Ue,Le),b(U,Ae),D(Se,U,null),b(U,Me),b(U,xe),b(xe,Fe),b(xe,Ye),b(Ye,ze),b(xe,Be),b(xe,Ve),b(Ve,He),b(xe,Qe),b(xe,Re),b(Re,Xe),b(xe,Je),b(xe,Ke),b(Ke,We),b(xe,Ze),b(xe,_e),b(_e,et),b(xe,tt),b(xe,at),b(at,nt),b(xe,st),b(xe,rt),b(rt,ot),b(xe,it),b(U,ht),D(ct,U,null),b(U,lt),b(U,dt),b(dt,ut),b(dt,yt),b(yt,ft),b(dt,mt),b(U,Et),b(U,vt),b(vt,pt),b(pt,gt),b(gt,$t),b(pt,wt),b(pt,bt),b(bt,Ct),b(Ct,Dt),b(bt,It),b(bt,Ot),b(Ot,Tt),b(bt,kt),b(bt,jt),b(jt,Nt),b(vt,Ut),b(vt,qt),b(qt,Pt),b(Pt,Gt),b(qt,Lt),b(qt,At),b(At,St),b(St,Mt),b(At,xt),b(At,Ft),b(Ft,Yt),b(At,zt),b(At,Bt),b(Bt,Vt),b(At,Ht),b(At,Qt),b(Qt,Rt),b(vt,Xt),b(vt,Jt),b(Jt,Kt),b(Kt,Wt),b(Jt,Zt),b(Jt,_t),b(_t,ea),b(Jt,ta),b(Jt,aa),b(aa,na),b(Jt,sa),b(Jt,ra),b(ra,oa),b(Jt,ia),b(Jt,ha),b(ha,ca),b(Jt,la),b(vt,da),b(vt,ua),b(ua,ya),b(ya,fa),b(ua,ma),b(ua,Ea),b(Ea,va),b(ua,pa),b(ua,ga),b(ga,$a),b(ua,wa),b(ua,ba),b(ba,Ca),b(ua,Da),b(ua,Ia),b(Ia,Oa),b(ua,Ta),b(ua,ka),b(ka,ja),b(ua,Na),b(U,Ua),D(qa,U,null),b(U,Pa),b(U,Ga),b(Ga,La),b(Ga,Aa),b(Aa,Sa),b(Ga,Ma),b(Ga,xa),b(xa,Fa),b(Ga,Ya),b(U,za),b(U,Ba),b(Ba,Va),b(Va,Ha),b(Ha,Qa),b(Va,Ra),b(Ba,Xa),b(Ba,Ja),b(Ja,Ka),b(Ka,Wa),b(Ja,Za),b(Ba,_a),b(Ba,en),b(en,tn),b(tn,an),b(en,nn),b(U,sn),b(U,rn),b(rn,on),b(rn,hn),b(hn,cn),b(rn,ln),b(rn,dn),b(dn,un),b(rn,yn),b(U,fn),b(U,mn),b(mn,En),b(mn,vn),b(vn,pn),b(mn,gn),b(U,$n),b(U,wn),b(wn,bn),b(wn,Cn),b(Cn,Dn),b(wn,In),b(wn,On),b(On,Tn),b(wn,kn),b(wn,jn),b(jn,Nn),b(wn,Un),b(U,qn),D(Pn,U,null),C(e,Gn,n),C(e,Ln,n),b(Ln,An),b(An,Sn),b(Sn,Mn),b(Mn,xn),b(An,Fn),b(An,Yn),b(Yn,zn),b(zn,Bn),Vn=!0},p:I,i(e){Vn||(O(oe.$$.fragment,e),O(je.$$.fragment,e),O(Se.$$.fragment,e),O(ct.$$.fragment,e),O(qa.$$.fragment,e),O(Pn.$$.fragment,e),Vn=!0)},o(e){T(oe.$$.fragment,e),T(je.$$.fragment,e),T(Se.$$.fragment,e),T(ct.$$.fragment,e),T(qa.$$.fragment,e),T(Pn.$$.fragment,e),Vn=!1},d(e){y(a),e&&t.d(),e&&y(N),e&&y(U),k(oe),k(je),k(Se),k(ct),k(qa),k(Pn),e&&y(Gn),e&&y(Ln)}}}class U extends e{constructor(e){super(),t(this,e,null,N,a,{})}}export{U as default};
