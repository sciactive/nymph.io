import{S as e,i as t,s as n,a0 as a,a1 as s,a2 as i,l as r,k as o,e as c,t as l,j as h,L as d,a3 as f,d as y,n as u,c as g,a as v,g as p,m,X as E,b as w,a4 as $,F as b,f as I,o as D,G as k,x as T,u as N,v as P}from"../../chunks/vendor-836b274b.js";import{b as C}from"../../chunks/paths-6758d194.js";function S(e){let t,n,S,j,O,G,W,x,R,A,B,U,V,q,Y,z,F,H,M,Q,L,X,J,K,Z,_,ee,te,ne,ae,se,ie,re,oe,ce,le,he,de,fe,ye,ue,ge,ve,pe,me,Ee,we,$e,be,Ie,De,ke,Te,Ne,Pe,Ce,Se,je,Oe,Ge,We,xe,Re,Ae,Be,Ue,Ve,qe,Ye,ze,Fe,He,Me,Qe,Le,Xe;return L=new a({props:{language:s,code:'// BlogPost extends the Entity class.\nlet blogPost = await BlogPost.factory();\n\n// Check that the entity is new.\nif (someBlogPost.guid == null) {\n  alert("This blog post hasn\'t been saved yet!");\n}'}}),_=new a({props:{language:s,code:"blogPost.$addTag('super-post');\nawait blogPost.$save();\n\nlet superPosts = await Nymph.getEntities(\n  { class: BlogPost.class },\n  { type: '&', tag: 'super-post' }\n);\n\nblogPost.$inArray(superPosts); // true"}}),de=new a({props:{language:s,code:"let entity = await Entity.factory();\nentity.foo = await Entity.factory();\n\nentity.foo.bar = 'It works!';\nawait entity.foo.$save(); // Saving the referenced entity first! :)\nawait entity.$save(); // now foo has been saved.\n\nconst guid = entity.guid;\nentity = await Entity.factory(guid);\n\nentity.foo.guid == null; // False\nconsole.log(entity.foo.bar); // Outputs 'It works!'."}}),we=new a({props:{language:s,code:"let entity = await Entity.factory();\nentity.foo = await Entity.factory();\n\nawait entity.$save(); // foo hasn't been saved yet!\n\nentity.foo.bar = 'It works!';\nawait entity.foo.$save();\n\nconst guid = entity.guid;\nentity = await Entity.factory(guid);\n\nentity.foo.guid == null; // True\nconsole.log(entity.foo.bar); // Outputs undefined."}}),{c(){t=new i,n=r(),S=o(),j=c("section"),O=c("header"),G=c("h1"),W=l("Creating Entities"),x=o(),R=c("p"),A=l("To create or retrieve an entity, you can call the "),B=c("code"),U=l("factory"),V=l("\n    static method of an entity's class and pass in an optional GUID. You can also\n    use the "),q=c("code"),Y=l("factorySync"),z=l(" method if you need to create a new entity\n    synchronously. The benefit of using the factory method is that it can return\n    the correct type in TypeScript. To check that an entity hasn't been saved\n    yet, check that the GUID is null ("),F=c("code"),H=l("entity.guid == null"),M=l(")."),Q=o(),h(L.$$.fragment),X=o(),J=c("p"),K=l("Much like entries in many blogging systems, entities can be organized using\n    tags. The tags provide a fast way to query entities."),Z=o(),h(_.$$.fragment),ee=o(),te=c("p"),ne=l("Be cautious when saving an entity in another entity's property. If the\n    referenced entity is newly created and does not have a GUID, Nymph will not\n    be able to retrieve it later. Always save the referenced entity first."),ae=o(),se=c("div"),ie=c("div"),re=l("Saving a Referenced Entity the "),oe=c("strong"),ce=l("Right"),le=l(" Way"),he=o(),h(de.$$.fragment),fe=o(),ye=c("div"),ue=c("div"),ge=l("Saving a Referenced Entity the "),ve=c("strong"),pe=l("Wrong"),me=l(" Way"),Ee=o(),h(we.$$.fragment),$e=o(),be=c("p"),Ie=l("Caution: Since the referenced entity's class name is stored in the reference\n    on the parent entity, if you change the class name in an update, you need to\n    reassign all referenced entities of that class and resave."),De=o(),ke=c("p"),Te=l('When an entity is loaded, it does not request its referenced entities from\n    Nymph. Instead, it creates instances without data called "sleeping\n    references". When you first access an entity\'s data (in Node.js), if it is a\n    sleeping reference, it will fill its data from the DB. You can call\n    '),Ne=c("code"),Pe=l("$clearCache"),Ce=l(" in Node.js or "),Se=c("code"),je=l("$refresh"),Oe=l(" in the client to\n    turn all the entities back into sleeping references."),Ge=o(),We=c("p"),xe=l("In the client, the "),Re=c("code"),Ae=l("$readyAll"),Be=l(" method can be used to awaken all sleeping\n    references in the entity's data. This is the most convenient way to do this,\n    since, unlike in Node.js, the sleeping reference can't just be loaded when it\n    is first accessed."),Ue=o(),Ve=c("section"),qe=c("div"),Ye=c("div"),ze=c("a"),Fe=l("Previous: Introduction"),He=o(),Me=c("div"),Qe=c("a"),Le=l("Next: Entity Querying"),this.h()},l(e){const a=d('[data-svelte="svelte-1vd957s"]',document.head);t=f(a),n=r(),a.forEach(y),S=u(e),j=g(e,"SECTION",{});var s=v(j);O=g(s,"HEADER",{class:!0});var i=v(O);G=g(i,"H1",{style:!0});var o=v(G);W=p(o,"Creating Entities"),o.forEach(y),i.forEach(y),x=u(s),R=g(s,"P",{});var c=v(R);A=p(c,"To create or retrieve an entity, you can call the "),B=g(c,"CODE",{});var l=v(B);U=p(l,"factory"),l.forEach(y),V=p(c,"\n    static method of an entity's class and pass in an optional GUID. You can also\n    use the "),q=g(c,"CODE",{});var h=v(q);Y=p(h,"factorySync"),h.forEach(y),z=p(c," method if you need to create a new entity\n    synchronously. The benefit of using the factory method is that it can return\n    the correct type in TypeScript. To check that an entity hasn't been saved\n    yet, check that the GUID is null ("),F=g(c,"CODE",{});var E=v(F);H=p(E,"entity.guid == null"),E.forEach(y),M=p(c,")."),c.forEach(y),Q=u(s),m(L.$$.fragment,s),X=u(s),J=g(s,"P",{});var w=v(J);K=p(w,"Much like entries in many blogging systems, entities can be organized using\n    tags. The tags provide a fast way to query entities."),w.forEach(y),Z=u(s),m(_.$$.fragment,s),ee=u(s),te=g(s,"P",{});var $=v(te);ne=p($,"Be cautious when saving an entity in another entity's property. If the\n    referenced entity is newly created and does not have a GUID, Nymph will not\n    be able to retrieve it later. Always save the referenced entity first."),$.forEach(y),ae=u(s),se=g(s,"DIV",{});var b=v(se);ie=g(b,"DIV",{style:!0});var I=v(ie);re=p(I,"Saving a Referenced Entity the "),oe=g(I,"STRONG",{});var D=v(oe);ce=p(D,"Right"),D.forEach(y),le=p(I," Way"),I.forEach(y),he=u(b),m(de.$$.fragment,b),b.forEach(y),fe=u(s),ye=g(s,"DIV",{});var k=v(ye);ue=g(k,"DIV",{style:!0});var T=v(ue);ge=p(T,"Saving a Referenced Entity the "),ve=g(T,"STRONG",{});var N=v(ve);pe=p(N,"Wrong"),N.forEach(y),me=p(T," Way"),T.forEach(y),Ee=u(k),m(we.$$.fragment,k),k.forEach(y),$e=u(s),be=g(s,"P",{});var P=v(be);Ie=p(P,"Caution: Since the referenced entity's class name is stored in the reference\n    on the parent entity, if you change the class name in an update, you need to\n    reassign all referenced entities of that class and resave."),P.forEach(y),De=u(s),ke=g(s,"P",{});var C=v(ke);Te=p(C,'When an entity is loaded, it does not request its referenced entities from\n    Nymph. Instead, it creates instances without data called "sleeping\n    references". When you first access an entity\'s data (in Node.js), if it is a\n    sleeping reference, it will fill its data from the DB. You can call\n    '),Ne=g(C,"CODE",{});var Xe=v(Ne);Pe=p(Xe,"$clearCache"),Xe.forEach(y),Ce=p(C," in Node.js or "),Se=g(C,"CODE",{});var Je=v(Se);je=p(Je,"$refresh"),Je.forEach(y),Oe=p(C," in the client to\n    turn all the entities back into sleeping references."),C.forEach(y),Ge=u(s),We=g(s,"P",{});var Ke=v(We);xe=p(Ke,"In the client, the "),Re=g(Ke,"CODE",{});var Ze=v(Re);Ae=p(Ze,"$readyAll"),Ze.forEach(y),Be=p(Ke," method can be used to awaken all sleeping\n    references in the entity's data. This is the most convenient way to do this,\n    since, unlike in Node.js, the sleeping reference can't just be loaded when it\n    is first accessed."),Ke.forEach(y),s.forEach(y),Ue=u(e),Ve=g(e,"SECTION",{});var _e=v(Ve);qe=g(_e,"DIV",{class:!0});var et=v(qe);Ye=g(et,"DIV",{class:!0});var tt=v(Ye);ze=g(tt,"A",{href:!0,class:!0,style:!0});var nt=v(ze);Fe=p(nt,"Previous: Introduction"),nt.forEach(y),tt.forEach(y),He=u(et),Me=g(et,"DIV",{class:!0,style:!0});var at=v(Me);Qe=g(at,"A",{href:!0,class:!0,style:!0});var st=v(Qe);Le=p(st,"Next: Entity Querying"),st.forEach(y),at.forEach(y),et.forEach(y),_e.forEach(y),this.h()},h(){document.title="Creating Entities - User Guide - Nymph",t.a=n,E(G,"font-size","3em"),w(O,"class","major"),E(ie,"text-align","end"),E(ue,"text-align","end"),w(ze,"href",C+"/user-guide/introduction"),w(ze,"class","button"),E(ze,"margin",".5em"),w(Ye,"class","col-6 col-12-small"),w(Qe,"href",C+"/user-guide/entity-querying"),w(Qe,"class","button"),E(Qe,"margin",".5em"),w(Me,"class","col-6 col-12-small"),E(Me,"text-align","end"),w(qe,"class","row")},m(e,a){t.m($,document.head),b(document.head,n),I(e,S,a),I(e,j,a),b(j,O),b(O,G),b(G,W),b(j,x),b(j,R),b(R,A),b(R,B),b(B,U),b(R,V),b(R,q),b(q,Y),b(R,z),b(R,F),b(F,H),b(R,M),b(j,Q),D(L,j,null),b(j,X),b(j,J),b(J,K),b(j,Z),D(_,j,null),b(j,ee),b(j,te),b(te,ne),b(j,ae),b(j,se),b(se,ie),b(ie,re),b(ie,oe),b(oe,ce),b(ie,le),b(se,he),D(de,se,null),b(j,fe),b(j,ye),b(ye,ue),b(ue,ge),b(ue,ve),b(ve,pe),b(ue,me),b(ye,Ee),D(we,ye,null),b(j,$e),b(j,be),b(be,Ie),b(j,De),b(j,ke),b(ke,Te),b(ke,Ne),b(Ne,Pe),b(ke,Ce),b(ke,Se),b(Se,je),b(ke,Oe),b(j,Ge),b(j,We),b(We,xe),b(We,Re),b(Re,Ae),b(We,Be),I(e,Ue,a),I(e,Ve,a),b(Ve,qe),b(qe,Ye),b(Ye,ze),b(ze,Fe),b(qe,He),b(qe,Me),b(Me,Qe),b(Qe,Le),Xe=!0},p:k,i(e){Xe||(T(L.$$.fragment,e),T(_.$$.fragment,e),T(de.$$.fragment,e),T(we.$$.fragment,e),Xe=!0)},o(e){N(L.$$.fragment,e),N(_.$$.fragment,e),N(de.$$.fragment,e),N(we.$$.fragment,e),Xe=!1},d(e){y(n),e&&t.d(),e&&y(S),e&&y(j),P(L),P(_),P(de),P(we),e&&y(Ue),e&&y(Ve)}}}class j extends e{constructor(e){super(),t(this,e,null,S,n,{})}}export{j as default};
