import{S as e,i as a,s as n,k as t,e as s,t as i,L as r,d as o,n as h,c,a as d,g as l,X as y,b as p,f as u,F as m,G as f}from"../../chunks/vendor-836b274b.js";function g(e){let a,n,g,v,b,w,E,N,I,P,D,j,A,S,U,T,k,H,G,O,R,q,W,$,x,C,J,M,Y,F,L,X,z,_,B,K,Q,V,Z,ee,ae,ne,te,se,ie,re,oe,he,ce,de,le,ye,pe,ue,me,fe,ge,ve,be,we,Ee,Ne,Ie,Pe,De,je,Ae;return{c(){a=t(),n=s("section"),g=s("header"),v=s("h1"),b=i("Introduction"),w=t(),E=s("p"),N=i("Nymph is an ORM for Node.js and the browser, written in TypeScript. Nymph\n    data objects, called entities, are accessed just like plain objects. Nymph\n    includes a REST server and a Publish/Subscribe server. Nymph is the ORM that\n    powered the Pines Framework, which ran a high demand ecommerce website and\n    Point of Sale system. It used to be a PHP library, but was migrated to\n    Node.js in 2021."),I=t(),P=s("header"),D=s("h2"),j=i("Understanding Nymph Applications"),A=t(),S=s("p"),U=i("Data in Nymph is stored and manipulated in objects called "),T=s("strong"),k=i("entities"),H=i(". Entities can hold most types of data available in JavaScript, including\n    other entities. Entities are not strictly structured, so data of any type\n    can be added and saved just by assigning a property on the entity and\n    calling "),G=s("code"),O=i("$save"),R=i(". This makes data manipulation and rapid\n    prototyping in Nymph very easy. Then when you're ready to launch to\n    production, you would use a validation library to enforce a schema for your\n    entities.\n    "),q=s("a"),W=i("Joi"),$=i("\n    is a good one. You can do this in the\n    "),x=s("code"),C=i("$save"),J=i("\n    method on your entities before calling\n    "),M=s("code"),Y=i("return await super.$save();"),F=i(". This means that during\n    development, you don't need to worry about managing schemas at all, but you\n    still get the benefit of strictly typed data checks in production."),L=t(),X=s("p"),z=i("All entities are given a globally unique identifier (GUID), which is a\n    random, cryptographically secure, 12 byte integer, encoded in a 24\n    character, lowercase HEX string. Since these are generated randomly, and\n    quite large, there should never be any two entities in any Nymph\n    installation with the same GUIDs (unless that's done on purpose). Nymph also\n    provides UIDs, which are sequential and can be used to number entities (or\n    anything else). UIDs can be used to provide a more visibly pleasing\n    identifier for entities."),_=t(),B=s("p"),K=i("Using Nymph, nearly all of an app's business logic can be written on either\n    the client side or the server side, since you interact with data the same\n    way in each. Anything that relies on access control can be handled on the\n    server side where Tilmeld, Nymph's optional user/group and access control\n    manager, provides security."),Q=t(),V=s("p"),Z=i("If an entity is referenced in another entity's property, the class is saved\n    along with the GUID. When this property is accessed later, Nymph will\n    retrieve the referenced entity using the saved class."),ee=t(),ae=s("p"),ne=i('When an entity containing a referenced entity is pulled from the database,\n    the referenced entity will exist in the data as a "sleeping reference".\n    Sleeping references have the right class and know their GUID, but other data\n    is not accessible until its pulled from the database. In Node.js, this\n    happens automatically when the data is accessed. In the client, this happens\n    when you use the '),te=s("code"),se=i("$ready"),ie=i(" method."),re=t(),oe=s("p"),he=i("When querying entities with Nymph, the ETYPE constant on the class\n    determines which database table(s) Nymph will look in."),ce=t(),de=s("p"),le=i("Caution: When changing an entity's class name, any entities referencing it\n    must be resaved after setting the reference again using the new class name."),ye=t(),pe=s("header"),ue=s("h2"),me=i("API Docs"),fe=t(),ge=s("p"),ve=i("If you want to really dive deep into Nymph, you can also browse the "),be=s("a"),we=i("API docs"),Ee=i(", which covers every part of Nymph's API."),Ne=t(),Ie=s("p"),Pe=i("If you need help with the old version of Nymph, that ran on PHP, you can\n    browse the "),De=s("a"),je=i("Legacy API docs"),Ae=i("."),this.h()},l(e){r('[data-svelte="svelte-i03alo"]',document.head).forEach(o),a=h(e),n=c(e,"SECTION",{});var t=d(n);g=c(t,"HEADER",{class:!0});var s=d(g);v=c(s,"H1",{style:!0});var i=d(v);b=l(i,"Introduction"),i.forEach(o),s.forEach(o),w=h(t),E=c(t,"P",{});var y=d(E);N=l(y,"Nymph is an ORM for Node.js and the browser, written in TypeScript. Nymph\n    data objects, called entities, are accessed just like plain objects. Nymph\n    includes a REST server and a Publish/Subscribe server. Nymph is the ORM that\n    powered the Pines Framework, which ran a high demand ecommerce website and\n    Point of Sale system. It used to be a PHP library, but was migrated to\n    Node.js in 2021."),y.forEach(o),I=h(t),P=c(t,"HEADER",{class:!0});var p=d(P);D=c(p,"H2",{});var u=d(D);j=l(u,"Understanding Nymph Applications"),u.forEach(o),p.forEach(o),A=h(t),S=c(t,"P",{});var m=d(S);U=l(m,"Data in Nymph is stored and manipulated in objects called "),T=c(m,"STRONG",{});var f=d(T);k=l(f,"entities"),f.forEach(o),H=l(m,". Entities can hold most types of data available in JavaScript, including\n    other entities. Entities are not strictly structured, so data of any type\n    can be added and saved just by assigning a property on the entity and\n    calling "),G=c(m,"CODE",{});var Se=d(G);O=l(Se,"$save"),Se.forEach(o),R=l(m,". This makes data manipulation and rapid\n    prototyping in Nymph very easy. Then when you're ready to launch to\n    production, you would use a validation library to enforce a schema for your\n    entities.\n    "),q=c(m,"A",{href:!0,target:!0});var Ue=d(q);W=l(Ue,"Joi"),Ue.forEach(o),$=l(m,"\n    is a good one. You can do this in the\n    "),x=c(m,"CODE",{});var Te=d(x);C=l(Te,"$save"),Te.forEach(o),J=l(m,"\n    method on your entities before calling\n    "),M=c(m,"CODE",{});var ke=d(M);Y=l(ke,"return await super.$save();"),ke.forEach(o),F=l(m,". This means that during\n    development, you don't need to worry about managing schemas at all, but you\n    still get the benefit of strictly typed data checks in production."),m.forEach(o),L=h(t),X=c(t,"P",{});var He=d(X);z=l(He,"All entities are given a globally unique identifier (GUID), which is a\n    random, cryptographically secure, 12 byte integer, encoded in a 24\n    character, lowercase HEX string. Since these are generated randomly, and\n    quite large, there should never be any two entities in any Nymph\n    installation with the same GUIDs (unless that's done on purpose). Nymph also\n    provides UIDs, which are sequential and can be used to number entities (or\n    anything else). UIDs can be used to provide a more visibly pleasing\n    identifier for entities."),He.forEach(o),_=h(t),B=c(t,"P",{});var Ge=d(B);K=l(Ge,"Using Nymph, nearly all of an app's business logic can be written on either\n    the client side or the server side, since you interact with data the same\n    way in each. Anything that relies on access control can be handled on the\n    server side where Tilmeld, Nymph's optional user/group and access control\n    manager, provides security."),Ge.forEach(o),Q=h(t),V=c(t,"P",{});var Oe=d(V);Z=l(Oe,"If an entity is referenced in another entity's property, the class is saved\n    along with the GUID. When this property is accessed later, Nymph will\n    retrieve the referenced entity using the saved class."),Oe.forEach(o),ee=h(t),ae=c(t,"P",{});var Re=d(ae);ne=l(Re,'When an entity containing a referenced entity is pulled from the database,\n    the referenced entity will exist in the data as a "sleeping reference".\n    Sleeping references have the right class and know their GUID, but other data\n    is not accessible until its pulled from the database. In Node.js, this\n    happens automatically when the data is accessed. In the client, this happens\n    when you use the '),te=c(Re,"CODE",{});var qe=d(te);se=l(qe,"$ready"),qe.forEach(o),ie=l(Re," method."),Re.forEach(o),re=h(t),oe=c(t,"P",{});var We=d(oe);he=l(We,"When querying entities with Nymph, the ETYPE constant on the class\n    determines which database table(s) Nymph will look in."),We.forEach(o),ce=h(t),de=c(t,"P",{});var $e=d(de);le=l($e,"Caution: When changing an entity's class name, any entities referencing it\n    must be resaved after setting the reference again using the new class name."),$e.forEach(o),ye=h(t),pe=c(t,"HEADER",{class:!0});var xe=d(pe);ue=c(xe,"H2",{});var Ce=d(ue);me=l(Ce,"API Docs"),Ce.forEach(o),xe.forEach(o),fe=h(t),ge=c(t,"P",{});var Je=d(ge);ve=l(Je,"If you want to really dive deep into Nymph, you can also browse the "),be=c(Je,"A",{href:!0,rel:!0});var Me=d(be);we=l(Me,"API docs"),Me.forEach(o),Ee=l(Je,", which covers every part of Nymph's API."),Je.forEach(o),Ne=h(t),Ie=c(t,"P",{});var Ye=d(Ie);Pe=l(Ye,"If you need help with the old version of Nymph, that ran on PHP, you can\n    browse the "),De=c(Ye,"A",{href:!0,rel:!0});var Fe=d(De);je=l(Fe,"Legacy API docs"),Fe.forEach(o),Ae=l(Ye,"."),Ye.forEach(o),t.forEach(o),this.h()},h(){document.title="Introduction - User Guide - Nymph",y(v,"font-size","3em"),p(g,"class","major"),p(P,"class","major"),p(q,"href","https://joi.dev/"),p(q,"target","_blank"),p(pe,"class","major"),p(be,"href","/api/latest"),p(be,"rel","external"),p(De,"href","/api/legacy/3.0.0/index.html"),p(De,"rel","external")},m(e,t){u(e,a,t),u(e,n,t),m(n,g),m(g,v),m(v,b),m(n,w),m(n,E),m(E,N),m(n,I),m(n,P),m(P,D),m(D,j),m(n,A),m(n,S),m(S,U),m(S,T),m(T,k),m(S,H),m(S,G),m(G,O),m(S,R),m(S,q),m(q,W),m(S,$),m(S,x),m(x,C),m(S,J),m(S,M),m(M,Y),m(S,F),m(n,L),m(n,X),m(X,z),m(n,_),m(n,B),m(B,K),m(n,Q),m(n,V),m(V,Z),m(n,ee),m(n,ae),m(ae,ne),m(ae,te),m(te,se),m(ae,ie),m(n,re),m(n,oe),m(oe,he),m(n,ce),m(n,de),m(de,le),m(n,ye),m(n,pe),m(pe,ue),m(ue,me),m(n,fe),m(n,ge),m(ge,ve),m(ge,be),m(be,we),m(ge,Ee),m(n,Ne),m(n,Ie),m(Ie,Pe),m(Ie,De),m(De,je),m(Ie,Ae)},p:f,i:f,o:f,d(e){e&&o(a),e&&o(n)}}}class v extends e{constructor(e){super(),a(this,e,null,g,n,{})}}export{v as default};
