import{S as e,i as t,s as a,a0 as n,a1 as s,a2 as o,l as i,k as r,e as h,t as c,j as d,L as l,a3 as p,d as y,n as m,c as u,a as f,g,m as v,X as E,b as w,a4 as T,F as $,f as D,o as b,G as N,x as C,u as j,v as x}from"../../chunks/vendor-836b274b.js";import{b as O}from"../../chunks/paths-6758d194.js";function I(e){let t,a,I,P,k,S,J,V,A,Y,q,M,U,B,W,z,F,G,H,R,L,X,_,K,Q,Z,ee,te,ae,ne,se,oe,ie,re,he,ce,de,le,pe,ye,me,ue,fe,ge,ve,Ee,we,Te,$e,De,be,Ne,Ce,je,xe,Oe,Ie,Pe,ke,Se,Je,Ve,Ae,Ye,qe,Me,Ue,Be,We,ze,Fe,Ge,He,Re,Le,Xe,_e,Ke,Qe,Ze,et,tt,at,nt,st,ot,it,rt,ht,ct,dt,lt,pt,yt,mt,ut,ft,gt,vt,Et,wt,Tt,$t,Dt,bt,Nt,Ct,jt,xt,Ot,It,Pt,kt,St;return H=new n({props:{language:s,code:"import { Entity, Selector, nymphJoiProps } from '@nymphjs/nymph';\nimport { tilmeldJoiProps } from '@nymphjs/tilmeld';\nimport Joi from 'joi';\n\nexport type TodoData = {\n  name?: string;\n  done?: boolean;\n};\n\nexport class Todo extends Entity<TodoData> {\n  static ETYPE = 'todo';\n  static class = 'Todo';\n\n  protected $clientEnabledMethods = ['$archive'];\n  protected $allowlistData? = ['name', 'done'];\n  protected $protectedTags = ['archived'];\n  protected $allowlistTags? = [];\n\n  static async factory(guid?: string): Promise<Todo & TodoData> {\n    return (await super.factory(guid)) as Todo & TodoData;\n  }\n\n  static factorySync(guid?: string): Todo & TodoData {\n    return super.factorySync(guid) as Todo & TodoData;\n  }\n\n  constructor(guid?: string) {\n    super(guid);\n\n    if (this.guid == null) {\n      this.$data.name = '';\n      this.$data.done = false;\n    }\n  }\n\n  async $archive() {\n    if (this.$hasTag('archived')) {\n      return true;\n    }\n    this.$addTag('archived');\n    return await this.$save();\n  }\n\n  async $save() {\n    if (!this.$nymph.tilmeld?.gatekeeper()) {\n      // Only allow logged in users to save.\n      throw new Error('You are not logged in.');\n    }\n\n    // Validate the entity's data.\n    Joi.attempt(\n      this.$getValidatable(),\n      Joi.object().keys({\n        ...nymphJoiProps,\n        ...tilmeldJoiProps,\n\n        name: Joi.string().trim(false).required(),\n        done: Joi.boolean().required(),\n      }),\n      'Invalid Todo: '\n    );\n\n    // Check that this is not a duplicate Todo.\n    const selector: Selector = {\n      type: '&',\n      equal: ['name', this.$data.name],\n    };\n    if (this.guid) {\n      selector['!guid'] = this.guid;\n    }\n    if (\n      await this.$nymph.getEntity(\n        {\n          class: this.constructor as typeof Todo,\n        },\n        selector\n      )\n    ) {\n      throw new Error('There is already a todo for that.');\n    }\n\n    return await super.$save();\n  }\n}\n\n// Elsewhere, after initializing Nymph.\nnymph.addEntityClass(Todo);"}}),Q=new n({props:{language:s,code:"import { Entity } from '@nymphjs/client';\n\nexport type TodoData = {\n  name?: string;\n  done?: boolean;\n};\n\nexport class Todo extends Entity<TodoData> {\n  // The name of the server class\n  public static class = 'Todo';\n\n  constructor(guid?: string) {\n    super(guid);\n\n    if (guid == null) {\n      this.$data.name = '';\n      this.$data.done = false;\n    }\n  }\n\n  static async factory(guid?: string): Promise<Todo & TodoData> {\n    return (await super.factory(guid)) as Todo & TodoData;\n  }\n\n  static factorySync(guid?: string): Todo & TodoData {\n    return super.factorySync(guid) as Todo & TodoData;\n  }\n\n  async $archive(): Promise<boolean> {\n    return await this.$serverCall('$archive', []);\n  }\n}\n\n// Elsewhere, after initializing Nymph.\nnymph.addEntityClass(Todo);"}}),{c(){t=new o,a=i(),I=r(),P=h("section"),k=h("header"),S=h("h1"),J=c("Defining Entities"),V=r(),A=h("p"),Y=c("To create a new type of data object in Nymph, you extend the "),q=h("code"),M=c("Entity"),U=c(" class. This is equivalent to creating a new table in a relational database.\n    If you are going to use the class on the client side, you also need to create\n    a corresponding client class. Below are two examples, one for Node.js, and one\n    for the client. A more in depth explanation follows the examples."),B=r(),W=h("div"),z=h("div"),F=c("Extending Entity in Node.js"),G=r(),d(H.$$.fragment),R=r(),L=h("div"),X=h("div"),_=c("Extending Entity in the Client"),K=r(),d(Q.$$.fragment),Z=r(),ee=h("p"),te=c("In both cases, defaults are set in the constructor. In this case, the "),ae=h("code"),ne=c("done"),se=c("\n    property is set to false and the "),oe=h("code"),ie=c("name"),re=c(" property is set to an\n    empty string. You can see that from within the methods of an entity, the\n    entity's data (other than guid, cdate, mdate, and tags) are accessed from\n    "),he=h("code"),ce=c("this.$data"),de=c(". The\n    "),le=h("code"),pe=c("$data"),ye=c(" part is not necessary outside of the entity's own methods."),me=r(),ue=h("p"),fe=c("You'll also notice that when using Nymph from within an entity's methods,\n    there is an instance of Nymph available in "),ge=h("code"),ve=c("this.$nymph"),Ee=c(" (or\n    "),we=h("code"),Te=c("this.nymph"),$e=c(" in static methods). Using this instance is\n    "),De=h("strong"),be=c("especially important in Node.js"),Ne=c(" for Nymph transactions and Tilmeld\n    authentication. These instances will know which user is logged in and add appropriate\n    permission checks, and will maintain a persistent DB connection during a transaction.\n    On the client, it is less important to use these instances, unless you run multiple\n    instances of the Nymph client in your app."),Ce=r(),je=h("p"),xe=c("In Node.js, the etype is set to "),Oe=h("code"),Ie=c('"todo"'),Pe=c(". The etype of an entity\n    determines which table(s) the entity will be placed in. When you search for\n    an entity, you give Nymph a class. Nymph will use that class' etype to\n    determine where to search for entities. If you don't provide a class, the\n    "),ke=h("code"),Se=c("Entity"),Je=c(' class and the "entity" etype will be used.'),Ve=r(),Ae=h("p"),Ye=c("The "),qe=h("code"),Me=c("$clientEnabledMethods"),Ue=c(" property and the\n    "),Be=h("code"),We=c("clientEnabledStaticMethods"),ze=c("\n    static property in Node.js determine which methods and static methods can be\n    called from the client using "),Fe=h("code"),Ge=c("$serverCall"),He=c(" and\n    "),Re=h("code"),Le=c("serverCallStatic"),Xe=c(". In the client class, the\n    "),_e=h("code"),Ke=c("return await this.$serverCall('archive', []);"),Qe=c(" statement takes advantage\n    of this feature."),Ze=r(),et=h("p"),tt=c("On each the Node.js class and the client class, the class name is set in the "),at=h("code"),nt=c("class"),st=c(" static property. This class name should match on each side. It is how Nymph\n    maps the client class to the Node.js class and vice versa."),ot=r(),it=h("p"),rt=c("Finally, in Node.js, the "),ht=h("code"),ct=c("Todo"),dt=c(" class validates all of its data\n    in the "),lt=h("code"),pt=c("$save"),yt=c(" method using\n    "),mt=h("a"),ut=c("Joi"),ft=c(". Without this validation,\n    a malicious user could send invalid data types or even megabytes worth of\n    data in an entity. Any validation library should support validation in Nymph\n    using the "),gt=h("code"),vt=c("$getValidatable"),Et=c(" method. The\n    "),wt=h("code"),Tt=c("$allowlistData"),$t=c(" property will ensure no extra properties are set."),Dt=r(),bt=h("section"),Nt=h("div"),Ct=h("div"),jt=h("a"),xt=c("Previous: Entity Class"),Ot=r(),It=h("div"),Pt=h("a"),kt=c("Next: UIDs"),this.h()},l(e){const n=l('[data-svelte="svelte-1kddyis"]',document.head);t=p(n),a=i(),n.forEach(y),I=m(e),P=u(e,"SECTION",{});var s=f(P);k=u(s,"HEADER",{class:!0});var o=f(k);S=u(o,"H1",{style:!0});var r=f(S);J=g(r,"Defining Entities"),r.forEach(y),o.forEach(y),V=m(s),A=u(s,"P",{});var h=f(A);Y=g(h,"To create a new type of data object in Nymph, you extend the "),q=u(h,"CODE",{});var c=f(q);M=g(c,"Entity"),c.forEach(y),U=g(h," class. This is equivalent to creating a new table in a relational database.\n    If you are going to use the class on the client side, you also need to create\n    a corresponding client class. Below are two examples, one for Node.js, and one\n    for the client. A more in depth explanation follows the examples."),h.forEach(y),B=m(s),W=u(s,"DIV",{});var d=f(W);z=u(d,"DIV",{style:!0});var E=f(z);F=g(E,"Extending Entity in Node.js"),E.forEach(y),G=m(d),v(H.$$.fragment,d),d.forEach(y),R=m(s),L=u(s,"DIV",{});var w=f(L);X=u(w,"DIV",{style:!0});var T=f(X);_=g(T,"Extending Entity in the Client"),T.forEach(y),K=m(w),v(Q.$$.fragment,w),w.forEach(y),Z=m(s),ee=u(s,"P",{});var $=f(ee);te=g($,"In both cases, defaults are set in the constructor. In this case, the "),ae=u($,"CODE",{});var D=f(ae);ne=g(D,"done"),D.forEach(y),se=g($,"\n    property is set to false and the "),oe=u($,"CODE",{});var b=f(oe);ie=g(b,"name"),b.forEach(y),re=g($," property is set to an\n    empty string. You can see that from within the methods of an entity, the\n    entity's data (other than guid, cdate, mdate, and tags) are accessed from\n    "),he=u($,"CODE",{});var N=f(he);ce=g(N,"this.$data"),N.forEach(y),de=g($,". The\n    "),le=u($,"CODE",{});var C=f(le);pe=g(C,"$data"),C.forEach(y),ye=g($," part is not necessary outside of the entity's own methods."),$.forEach(y),me=m(s),ue=u(s,"P",{});var j=f(ue);fe=g(j,"You'll also notice that when using Nymph from within an entity's methods,\n    there is an instance of Nymph available in "),ge=u(j,"CODE",{});var x=f(ge);ve=g(x,"this.$nymph"),x.forEach(y),Ee=g(j," (or\n    "),we=u(j,"CODE",{});var O=f(we);Te=g(O,"this.nymph"),O.forEach(y),$e=g(j," in static methods). Using this instance is\n    "),De=u(j,"STRONG",{});var St=f(De);be=g(St,"especially important in Node.js"),St.forEach(y),Ne=g(j," for Nymph transactions and Tilmeld\n    authentication. These instances will know which user is logged in and add appropriate\n    permission checks, and will maintain a persistent DB connection during a transaction.\n    On the client, it is less important to use these instances, unless you run multiple\n    instances of the Nymph client in your app."),j.forEach(y),Ce=m(s),je=u(s,"P",{});var Jt=f(je);xe=g(Jt,"In Node.js, the etype is set to "),Oe=u(Jt,"CODE",{});var Vt=f(Oe);Ie=g(Vt,'"todo"'),Vt.forEach(y),Pe=g(Jt,". The etype of an entity\n    determines which table(s) the entity will be placed in. When you search for\n    an entity, you give Nymph a class. Nymph will use that class' etype to\n    determine where to search for entities. If you don't provide a class, the\n    "),ke=u(Jt,"CODE",{});var At=f(ke);Se=g(At,"Entity"),At.forEach(y),Je=g(Jt,' class and the "entity" etype will be used.'),Jt.forEach(y),Ve=m(s),Ae=u(s,"P",{});var Yt=f(Ae);Ye=g(Yt,"The "),qe=u(Yt,"CODE",{});var qt=f(qe);Me=g(qt,"$clientEnabledMethods"),qt.forEach(y),Ue=g(Yt," property and the\n    "),Be=u(Yt,"CODE",{});var Mt=f(Be);We=g(Mt,"clientEnabledStaticMethods"),Mt.forEach(y),ze=g(Yt,"\n    static property in Node.js determine which methods and static methods can be\n    called from the client using "),Fe=u(Yt,"CODE",{});var Ut=f(Fe);Ge=g(Ut,"$serverCall"),Ut.forEach(y),He=g(Yt," and\n    "),Re=u(Yt,"CODE",{});var Bt=f(Re);Le=g(Bt,"serverCallStatic"),Bt.forEach(y),Xe=g(Yt,". In the client class, the\n    "),_e=u(Yt,"CODE",{});var Wt=f(_e);Ke=g(Wt,"return await this.$serverCall('archive', []);"),Wt.forEach(y),Qe=g(Yt," statement takes advantage\n    of this feature."),Yt.forEach(y),Ze=m(s),et=u(s,"P",{});var zt=f(et);tt=g(zt,"On each the Node.js class and the client class, the class name is set in the "),at=u(zt,"CODE",{});var Ft=f(at);nt=g(Ft,"class"),Ft.forEach(y),st=g(zt," static property. This class name should match on each side. It is how Nymph\n    maps the client class to the Node.js class and vice versa."),zt.forEach(y),ot=m(s),it=u(s,"P",{});var Gt=f(it);rt=g(Gt,"Finally, in Node.js, the "),ht=u(Gt,"CODE",{});var Ht=f(ht);ct=g(Ht,"Todo"),Ht.forEach(y),dt=g(Gt," class validates all of its data\n    in the "),lt=u(Gt,"CODE",{});var Rt=f(lt);pt=g(Rt,"$save"),Rt.forEach(y),yt=g(Gt," method using\n    "),mt=u(Gt,"A",{href:!0,target:!0});var Lt=f(mt);ut=g(Lt,"Joi"),Lt.forEach(y),ft=g(Gt,". Without this validation,\n    a malicious user could send invalid data types or even megabytes worth of\n    data in an entity. Any validation library should support validation in Nymph\n    using the "),gt=u(Gt,"CODE",{});var Xt=f(gt);vt=g(Xt,"$getValidatable"),Xt.forEach(y),Et=g(Gt," method. The\n    "),wt=u(Gt,"CODE",{});var _t=f(wt);Tt=g(_t,"$allowlistData"),_t.forEach(y),$t=g(Gt," property will ensure no extra properties are set."),Gt.forEach(y),s.forEach(y),Dt=m(e),bt=u(e,"SECTION",{});var Kt=f(bt);Nt=u(Kt,"DIV",{class:!0});var Qt=f(Nt);Ct=u(Qt,"DIV",{class:!0});var Zt=f(Ct);jt=u(Zt,"A",{href:!0,class:!0,style:!0});var ea=f(jt);xt=g(ea,"Previous: Entity Class"),ea.forEach(y),Zt.forEach(y),Ot=m(Qt),It=u(Qt,"DIV",{class:!0,style:!0});var ta=f(It);Pt=u(ta,"A",{href:!0,class:!0,style:!0});var aa=f(Pt);kt=g(aa,"Next: UIDs"),aa.forEach(y),ta.forEach(y),Qt.forEach(y),Kt.forEach(y),this.h()},h(){document.title="Defining Entities - User Guide - Nymph.js",t.a=a,E(S,"font-size","3em"),w(k,"class","major"),E(z,"text-align","end"),E(X,"text-align","end"),w(mt,"href","https://joi.dev/"),w(mt,"target","_blank"),w(jt,"href",O+"/user-guide/entity-class"),w(jt,"class","button"),E(jt,"margin",".5em"),w(Ct,"class","col-6 col-12-small"),w(Pt,"href",O+"/user-guide/uids"),w(Pt,"class","button"),E(Pt,"margin",".5em"),w(It,"class","col-6 col-12-small"),E(It,"text-align","end"),w(Nt,"class","row")},m(e,n){t.m(T,document.head),$(document.head,a),D(e,I,n),D(e,P,n),$(P,k),$(k,S),$(S,J),$(P,V),$(P,A),$(A,Y),$(A,q),$(q,M),$(A,U),$(P,B),$(P,W),$(W,z),$(z,F),$(W,G),b(H,W,null),$(P,R),$(P,L),$(L,X),$(X,_),$(L,K),b(Q,L,null),$(P,Z),$(P,ee),$(ee,te),$(ee,ae),$(ae,ne),$(ee,se),$(ee,oe),$(oe,ie),$(ee,re),$(ee,he),$(he,ce),$(ee,de),$(ee,le),$(le,pe),$(ee,ye),$(P,me),$(P,ue),$(ue,fe),$(ue,ge),$(ge,ve),$(ue,Ee),$(ue,we),$(we,Te),$(ue,$e),$(ue,De),$(De,be),$(ue,Ne),$(P,Ce),$(P,je),$(je,xe),$(je,Oe),$(Oe,Ie),$(je,Pe),$(je,ke),$(ke,Se),$(je,Je),$(P,Ve),$(P,Ae),$(Ae,Ye),$(Ae,qe),$(qe,Me),$(Ae,Ue),$(Ae,Be),$(Be,We),$(Ae,ze),$(Ae,Fe),$(Fe,Ge),$(Ae,He),$(Ae,Re),$(Re,Le),$(Ae,Xe),$(Ae,_e),$(_e,Ke),$(Ae,Qe),$(P,Ze),$(P,et),$(et,tt),$(et,at),$(at,nt),$(et,st),$(P,ot),$(P,it),$(it,rt),$(it,ht),$(ht,ct),$(it,dt),$(it,lt),$(lt,pt),$(it,yt),$(it,mt),$(mt,ut),$(it,ft),$(it,gt),$(gt,vt),$(it,Et),$(it,wt),$(wt,Tt),$(it,$t),D(e,Dt,n),D(e,bt,n),$(bt,Nt),$(Nt,Ct),$(Ct,jt),$(jt,xt),$(Nt,Ot),$(Nt,It),$(It,Pt),$(Pt,kt),St=!0},p:N,i(e){St||(C(H.$$.fragment,e),C(Q.$$.fragment,e),St=!0)},o(e){j(H.$$.fragment,e),j(Q.$$.fragment,e),St=!1},d(e){y(a),e&&t.d(),e&&y(I),e&&y(P),x(H),x(Q),e&&y(Dt),e&&y(bt)}}}class P extends e{constructor(e){super(),t(this,e,null,I,a,{})}}export{P as default};
