import{S as a,i as e,s as t,a0 as s,a5 as n,a1 as o,a2 as r,l as i,k as d,e as h,t as c,j as l,L as m,a3 as y,d as f,n as p,c as u,a as g,g as v,m as E,X as $,b as T,a4 as w,F as b,f as j,o as N,G as D,x as S,u as H,v as k}from"../../chunks/vendor-836b274b.js";import{b as x}from"../../chunks/paths-6758d194.js";function P(a){let e,t,P,q,A,L,Q,_,C,O,R,I,M,z,B,G,U,Y,F,W,X,J,K,V,Z,aa,ea,ta,sa,na,oa,ra,ia,da,ha,ca,la,ma,ya,fa,pa,ua,ga,va,Ea,$a,Ta,wa,ba,ja,Na,Da,Sa,Ha;return G=new s({props:{language:n,code:"npm install --save @nymphjs/nymph"}}),pa=new s({props:{language:o,code:"// main.ts\nimport { Nymph } from '@nymphjs/nymph';\nimport MySQLDriver from '@nymphjs/driver-mysql';\nimport Todo from './Todo';\n\nconst mysqlConfig = {\n  host: 'your_db_host',\n  database: 'your_database',\n  user: 'your_user',\n  password: 'your_password',\n};\n\nconst nymph = new Nymph({}, new MySQLDriver(mysqlConfig));\nnymph.addEntityClass(Todo);\n\n// You are set up. Now you can use entity classes like `Todo` to store data,\n// and Nymph's query methods like `getEntities` to retrieve them.\n\nasync function run() {\n  const myEntity = await Todo.factory();\n  myEntity.text = 'Get it done!';\n  await myEntity.$save();\n\n  const otherPendingTodos = await nymph.getEntities(\n    { class: Todo },\n    { type: '&', '!guid': myEntity.guid, equal: ['done', false] }\n  );\n\n  const total = otherPendingTodos.length;\n  const single = total === 1;\n  console.log(\n    `Besides the one I just created, there ${\n      single ? 'is' : 'are'\n    } ${total} pending todo${single ? '' : 's'} in the database.`\n  );\n}"}}),ga=new s({props:{language:o,code:"// Todo.ts\nimport { Entity } from '@nymphjs/nymph';\n\nexport type TodoData = {\n  text: string;\n  done: boolean;\n};\n\nexport default class Todo extends Entity<TodoData> {\n  static ETYPE = 'todo'; // This is used for the table name(s) in the DB.\n  static class = 'Todo'; // This is used to map references to their class.\n\n  static async factory(guid?: string): Promise<Todo & TodoData> {\n    return (await super.factory(guid)) as Todo & TodoData;\n  }\n\n  static factorySync(guid?: string): Todo & TodoData {\n    return super.factorySync(guid) as Todo & TodoData;\n  }\n\n  constructor(guid?: string) {\n    super(guid);\n\n    if (this.guid == null) {\n      // Within the methods of an entity, you will use `this.$data` to access\n      // its data. Outside, you don't need the $data part.\n      this.$data.text = '';\n      this.$data.done = false;\n    }\n  }\n\n  async $getOtherTodos() {\n    // this.$nymph (or this.nymph in a static function) is the instance of Nymph\n    // this entity was loaded with. Creating transactions will create a new\n    // instance of Nymph, so it could be a transactional instance.\n    const otherTodos = await this.$nymph.getEntities(\n      { class: Todo },\n      { type: '!&', guid: this.guid }\n    );\n    return otherTodos;\n  }\n}"}}),{c(){e=new r,t=i(),P=d(),q=h("section"),A=h("header"),L=h("h1"),Q=c("Nymph"),_=d(),C=h("p"),O=c("The Nymph core provides the base level classes and utilities to query the\n    database, save data to it, and define different data types."),R=d(),I=h("header"),M=h("h2"),z=c("Installation"),B=d(),l(G.$$.fragment),U=d(),Y=h("header"),F=h("h2"),W=c("Drivers"),X=d(),J=h("p"),K=c("To use Nymph, you need a database driver. Nymph.js provides a "),V=h("a"),Z=c("MySQL driver"),aa=c(", "),ea=h("a"),ta=c("PostgreSQL driver"),sa=c(", and a\n    "),na=h("a"),oa=c("SQLite3 driver"),ra=c("."),ia=d(),da=h("header"),ha=h("h2"),ca=c("Usage"),la=d(),ma=h("p"),ya=c("Here's an overview:"),fa=d(),l(pa.$$.fragment),ua=d(),l(ga.$$.fragment),va=d(),Ea=h("header"),$a=h("h2"),Ta=c("Options"),wa=d(),ba=h("p"),ja=c("See the "),Na=h("a"),Da=c("config declaration file"),Sa=c("."),this.h()},l(a){const s=m('[data-svelte="svelte-lxz0w1"]',document.head);e=y(s),t=i(),s.forEach(f),P=p(a),q=u(a,"SECTION",{});var n=g(q);A=u(n,"HEADER",{class:!0});var o=g(A);L=u(o,"H1",{style:!0});var r=g(L);Q=v(r,"Nymph"),r.forEach(f),o.forEach(f),_=p(n),C=u(n,"P",{});var d=g(C);O=v(d,"The Nymph core provides the base level classes and utilities to query the\n    database, save data to it, and define different data types."),d.forEach(f),R=p(n),I=u(n,"HEADER",{class:!0});var h=g(I);M=u(h,"H2",{});var c=g(M);z=v(c,"Installation"),c.forEach(f),h.forEach(f),B=p(n),E(G.$$.fragment,n),U=p(n),Y=u(n,"HEADER",{class:!0});var l=g(Y);F=u(l,"H2",{});var $=g(F);W=v($,"Drivers"),$.forEach(f),l.forEach(f),X=p(n),J=u(n,"P",{});var T=g(J);K=v(T,"To use Nymph, you need a database driver. Nymph.js provides a "),V=u(T,"A",{href:!0});var w=g(V);Z=v(w,"MySQL driver"),w.forEach(f),aa=v(T,", "),ea=u(T,"A",{href:!0});var b=g(ea);ta=v(b,"PostgreSQL driver"),b.forEach(f),sa=v(T,", and a\n    "),na=u(T,"A",{href:!0});var j=g(na);oa=v(j,"SQLite3 driver"),j.forEach(f),ra=v(T,"."),T.forEach(f),ia=p(n),da=u(n,"HEADER",{class:!0});var N=g(da);ha=u(N,"H2",{});var D=g(ha);ca=v(D,"Usage"),D.forEach(f),N.forEach(f),la=p(n),ma=u(n,"P",{});var S=g(ma);ya=v(S,"Here's an overview:"),S.forEach(f),fa=p(n),E(pa.$$.fragment,n),ua=p(n),E(ga.$$.fragment,n),va=p(n),Ea=u(n,"HEADER",{class:!0});var H=g(Ea);$a=u(H,"H2",{});var k=g($a);Ta=v(k,"Options"),k.forEach(f),H.forEach(f),wa=p(n),ba=u(n,"P",{});var x=g(ba);ja=v(x,"See the "),Na=u(x,"A",{href:!0,target:!0,rel:!0});var Ha=g(Na);Da=v(Ha,"config declaration file"),Ha.forEach(f),Sa=v(x,"."),x.forEach(f),n.forEach(f),this.h()},h(){document.title="Nymph - Packages - Nymph.js",e.a=t,$(L,"font-size","3em"),T(A,"class","major"),T(I,"class","major"),T(Y,"class","major"),T(V,"href",x+"/packages/driver-mysql"),T(ea,"href",x+"/packages/driver-postgresql"),T(na,"href",x+"/packages/driver-sqlite3"),T(da,"class","major"),T(Ea,"class","major"),T(Na,"href","https://github.com/sciactive/nymphjs/tree/master/packages/nymph/src/conf/d.ts"),T(Na,"target","_blank"),T(Na,"rel","external")},m(a,s){e.m(w,document.head),b(document.head,t),j(a,P,s),j(a,q,s),b(q,A),b(A,L),b(L,Q),b(q,_),b(q,C),b(C,O),b(q,R),b(q,I),b(I,M),b(M,z),b(q,B),N(G,q,null),b(q,U),b(q,Y),b(Y,F),b(F,W),b(q,X),b(q,J),b(J,K),b(J,V),b(V,Z),b(J,aa),b(J,ea),b(ea,ta),b(J,sa),b(J,na),b(na,oa),b(J,ra),b(q,ia),b(q,da),b(da,ha),b(ha,ca),b(q,la),b(q,ma),b(ma,ya),b(q,fa),N(pa,q,null),b(q,ua),N(ga,q,null),b(q,va),b(q,Ea),b(Ea,$a),b($a,Ta),b(q,wa),b(q,ba),b(ba,ja),b(ba,Na),b(Na,Da),b(ba,Sa),Ha=!0},p:D,i(a){Ha||(S(G.$$.fragment,a),S(pa.$$.fragment,a),S(ga.$$.fragment,a),Ha=!0)},o(a){H(G.$$.fragment,a),H(pa.$$.fragment,a),H(ga.$$.fragment,a),Ha=!1},d(a){f(t),a&&e.d(),a&&f(P),a&&f(q),k(G),k(pa),k(ga)}}}class q extends a{constructor(a){super(),e(this,a,null,P,t,{})}}export{q as default};
